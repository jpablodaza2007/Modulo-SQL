CREATE TABLE ESTUDIANTES (
ID_ESTUDIANTE INT,
NOMBRE VARCHAR(100),
APELLIDO VARCHAR(100),
FECHA_NACIMIENTO DATE,
PROMEDIO DECIMAL(4,2),
EMAIL VARCHAR(150),
ACTIVO BOOLEAN,
FECHA_INSCRIPCION TIMESTAMP
);

-- Esta tabla almacena información de productos
CREATE TABLE PRODUCTOS (
-- Identificador único de cada producto
ID_PRODUCTO INT NOT NULL,

-- Información básica del producto
NOMBRE_PRODUCTO VARCHAR(100) NOT NULL,
DESCRIPCION TEXT,

-- Información de precio e inventario
PRECIO DECIMAL(10,2) NOT NULL,
CANTIDAD_STOCK INT DEFAULT 0,

-- Información de proveedor
ID_PROVEEDOR INT,

-- Control de fechas
FECHA_ALTA DATE NOT NULL,
ULTIMA_ACTUALIZACION TIMESTAMP
);

CREATE TABLE EMPLEADOS (
ID_EMPLEADO INT PRIMARY KEY,
NOMBRE VARCHAR(100),
CARGO VARCHAR(50)
);

CREATE TABLE INSCRIPCIONES (
ID_ESTUDIANTE INT,
ID_CURSO INT,
FECHA_INSCRIPCION DATE,
PRIMARY KEY (ID_ESTUDIANTE, ID_CURSO)
);

-- Tabla principal de clientes
CREATE TABLE CLIENTES (
ID_CLIENTE INT PRIMARY KEY,
NOMBRE VARCHAR(100) NOT NULL,
EMAIL VARCHAR(100) UNIQUE
);

-- Tabla de pedidos que se relaciona con clientes
CREATE TABLE PEDIDOS (
ID_PEDIDO INT PRIMARY KEY,
ID_CLIENTE INT NOT NULL,
FECHA_PEDIDO DATE NOT NULL,
TOTAL DECIMAL(10,2),
-- Esta es la clave foránea
FOREIGN KEY (ID_CLIENTE)
REFERENCES CLIENTES(ID_CLIENTE)
);

CREATE TABLE PRODUCTOS (
ID_PRODUCTO INT PRIMARY KEY,
NOMBRE VARCHAR(100),
PRECIO DECIMAL(10,2),
DESCUENTO INT,
CHECK (PRECIO > 0),
CHECK (DESCUENTO >= 0 AND DESCUENTO <=
100)
);
CREATE TABLE EMPLEADOS (
ID_EMPLEADO INT PRIMARY KEY,
NOMBRE VARCHAR(100),
FECHA_NACIMIENTO DATE,
FECHA_CONTRATACION DATE,
CHECK (FECHA_CONTRATACION >
FECHA_NACIMIENTO)
);

CREATE TABLE ESTUDIANTES (
ID_ESTUDIANTE INT PRIMARY KEY,
NOMBRE VARCHAR(100),
GENERO CHAR(1),
ESTADO_CIVIL VARCHAR(20),
CHECK (GENERO IN ('M', 'F', 'O')),
CHECK (ESTADO_CIVIL IN ('Soltero', 'Casado',
'Divorciado', 'Viudo'))
);

CREATE TABLE PRODUCTOS (
ID_PRODUCTO INT
PRIMARY KEY,
NOMBRE VARCHAR(100),
STOCK INT DEFAULT 0,
ACTIVO BOOLEAN DEFAULT
TRUE,
DESCUENTO DECIMAL(5,2)
DEFAULT 0.00
);
CREATE TABLE REGISTROS (
ID_REGISTRO INT PRIMARY
KEY,
DESCRIPCION TEXT,
FECHA_CREACION DATE
DEFAULT CURRENT_DATE,
FECHA_ACTUALIZACION
TIMESTAMP DEFAULT
CURRENT_TIMESTAMP
);





CREATE TABLE LIBROS (
-- Identificador único del libro
ID_LIBRO INT PRIMARY KEY,

-- Información obligatoria del libro
TITULO VARCHAR(200) NOT NULL,
AUTOR VARCHAR(150) NOT NULL,
ISBN VARCHAR(13) UNIQUE NOT NULL,

-- Detalles del libro con validaciones
ANIO_PUBLICACION INT,
NUMERO_PAGINAS INT,
EDITORIAL VARCHAR(100),

-- Control de disponibilidad
DISPONIBLE BOOLEAN DEFAULT TRUE,
CANTIDAD_COPIAS INT DEFAULT 1,

-- Registro automático de fecha
FECHA_REGISTRO DATE DEFAULT CURRENT_DATE,

-- Validaciones con CHECK
CHECK (ANIO_PUBLICACION > 1000 AND ANIO_PUBLICACION <= EXTRACT(YEAR FROM CURRENT_DATE)),
CHECK (NUMERO_PAGINAS > 0),
CHECK (CANTIDAD_COPIAS >= 0)
);

ALTER TABLE
nombre_tabla
ADD COLUMN
nombre_columna
tipo_dato restricciones;

ALTER TABLE
nombre_tabla
ALTER COLUMN
nombre_columna SET
DEFAULT valor;
--ejemplo
ALTER TABLE LIBROS
ADD COLUMN CATEGORIA
VARCHAR(50);

ALTER TABLE
nombre_tabla
DROP COLUMN
nombre_columna;
--ejemplo
ALTER TABLE LIBROS
ALTER COLUMN
DISPONIBLE SET
DEFAULT FALSE;

ALTER TABLE LIBROS
DROP COLUMN
NUMERO_PAGINAS;
Eliminar Columnas
Sintaxis:
--Ejemplo:
ALTER TABLE LIBROS
DROP COLUMN
NUMERO_PAGINAS;

DROP TABLE nombre_tabla;
DROP TABLE nombre_tabla CASCADE;
DROP TABLE nombre_tabla RESTRICT;
-- Eliminar tabla temporal
DROP TABLE CALCULOS_TEMPORALES;

-- Con seguridad adicional
DROP TABLE IF EXISTS CALCULOS_TEMPORALES;

-- Tabla padre: CLIENTES (el "uno")
CREATE TABLE CLIENTES (
ID_CLIENTE INT PRIMARY KEY,
NOMBRE VARCHAR(100) NOT NULL,
EMAIL VARCHAR(100) UNIQUE,
TELEFONO VARCHAR(20),
FECHA_REGISTRO DATE DEFAULT CURRENT_DATE
);

-- Tabla hija: PEDIDOS (los "muchos")
CREATE TABLE PEDIDOS (
ID_PEDIDO INT PRIMARY KEY,
ID_CLIENTE INT NOT NULL, -- Clave foránea
FECHA_PEDIDO DATE DEFAULT CURRENT_DATE,
TOTAL DECIMAL(10,2) NOT NULL,
ESTADO VARCHAR(20) DEFAULT 'Pendiente',

-- Definimos la relación
FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTES(ID_CLIENTE)
ON DELETE RESTRICT -- No permite borrar cliente con pedidos
ON UPDATE CASCADE, -- Si cambia ID cliente, actualiza pedidos

CHECK (TOTAL > 0),
CHECK (ESTADO IN ('Pendiente', 'Procesando', 'Enviado', 'Entregado', 'Cancelado'))
);
-- Primera tabla: ESTUDIANTES
CREATE TABLE ESTUDIANTES (
ID_ESTUDIANTE INT PRIMARY KEY,
NOMBRE VARCHAR(100) NOT NULL,
APELLIDO VARCHAR(100) NOT NULL,
EMAIL VARCHAR(100) UNIQUE,
FECHA_INGRESO DATE DEFAULT CURRENT_DATE
);

-- Segunda tabla: CURSOS
CREATE TABLE CURSOS (
ID_CURSO INT PRIMARY KEY,
NOMBRE_CURSO VARCHAR(100) NOT NULL,
CODIGO_CURSO VARCHAR(20) UNIQUE NOT NULL,
CREDITOS INT,
CHECK (CREDITOS > 0)
);

-- Tabla intermedia: INSCRIPCIONES
-- Esta tabla convierte la relación N:M en dos relaciones 1:N
CREATE TABLE INSCRIPCIONES (
ID_INSCRIPCION INT PRIMARY KEY,
ID_ESTUDIANTE INT NOT NULL,
ID_CURSO INT NOT NULL,
FECHA_INSCRIPCION DATE DEFAULT CURRENT_DATE,
CALIFICACION DECIMAL(4,2),
ESTADO VARCHAR(20) DEFAULT 'Activo',

-- Relación con ESTUDIANTES
FOREIGN KEY (ID_ESTUDIANTE) REFERENCES ESTUDIANTES(ID_ESTUDIANTE)
ON DELETE CASCADE,

-- Relación con CURSOS
FOREIGN KEY (ID_CURSO) REFERENCES CURSOS(ID_CURSO)
ON DELETE CASCADE,

-- Un estudiante no puede inscribirse dos veces en el mismo curso
UNIQUE (ID_ESTUDIANTE, ID_CURSO),

CHECK (CALIFICACION >= 0 AND CALIFICACION <= 5),
CHECK (ESTADO IN ('Activo', 'Completado', 'Retirado', 'Reprobado'))
);

-- 1. Tabla de Clientes
CREATE TABLE CLIENTES (
ID_CLIENTE INT PRIMARY KEY,
NOMBRE VARCHAR(100) NOT NULL,
APELLIDO VARCHAR(100) NOT NULL,
EMAIL VARCHAR(100) UNIQUE NOT NULL,
TELEFONO VARCHAR(20),
DIRECCION TEXT,
CIUDAD VARCHAR(50),
FECHA_REGISTRO DATE DEFAULT CURRENT_DATE,
ACTIVO BOOLEAN DEFAULT TRUE
);

-- 2. Tabla de Categorías de Productos
CREATE TABLE CATEGORIAS (
ID_CATEGORIA INT PRIMARY KEY,
NOMBRE_CATEGORIA VARCHAR(50) UNIQUE NOT NULL,
DESCRIPCION TEXT
);

-- 3. Tabla de Productos
CREATE TABLE PRODUCTOS (
ID_PRODUCTO INT PRIMARY KEY,
NOMBRE_PRODUCTO VARCHAR(100) NOT NULL,
DESCRIPCION TEXT,
ID_CATEGORIA INT NOT NULL,
PRECIO_UNITARIO DECIMAL(10,2) NOT NULL,
STOCK_ACTUAL INT DEFAULT 0,
STOCK_MINIMO INT DEFAULT 10,
ACTIVO BOOLEAN DEFAULT TRUE,

FOREIGN KEY (ID_CATEGORIA) REFERENCES CATEGORIAS(ID_CATEGORIA),
CHECK (PRECIO_UNITARIO > 0),
CHECK (STOCK_ACTUAL >= 0),
CHECK (STOCK_MINIMO >= 0)
);
-- 4. Tabla de Pedidos (Cabecera)
CREATE TABLE PEDIDOS (
ID_PEDIDO INT PRIMARY KEY,
ID_CLIENTE INT NOT NULL,
FECHA_PEDIDO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
ESTADO VARCHAR(20) DEFAULT 'Pendiente',
SUBTOTAL DECIMAL(10,2) DEFAULT 0,
IMPUESTO DECIMAL(10,2) DEFAULT 0,
TOTAL DECIMAL(10,2) DEFAULT 0,
OBSERVACIONES TEXT,

FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTES(ID_CLIENTE),
CHECK (ESTADO IN ('Pendiente', 'Procesando', 'Enviado', 'Entregado', 'Cancelado')),
CHECK (SUBTOTAL >= 0),
CHECK (IMPUESTO >= 0),
CHECK (TOTAL >= 0)
);

-- 5. Tabla de Detalle de Pedidos (Líneas de pedido)
CREATE TABLE DETALLE_PEDIDOS (
ID_DETALLE INT PRIMARY KEY,
ID_PEDIDO INT NOT NULL,
ID_PRODUCTO INT NOT NULL,
CANTIDAD INT NOT NULL,
PRECIO_UNITARIO DECIMAL(10,2) NOT NULL,
DESCUENTO DECIMAL(5,2) DEFAULT 0,
SUBTOTAL DECIMAL(10,2) NOT NULL,

FOREIGN KEY (ID_PEDIDO) REFERENCES PEDIDOS(ID_PEDIDO) ON DELETE CASCADE,
FOREIGN KEY (ID_PRODUCTO) REFERENCES PRODUCTOS(ID_PRODUCTO),
CHECK (CANTIDAD > 0),
CHECK (PRECIO_UNITARIO > 0),
CHECK (DESCUENTO >= 0 AND DESCUENTO <= 100),
CHECK (SUBTOTAL >= 0)
);

-- 6. Tabla de Métodos de Pago
CREATE TABLE PAGOS (
ID_PAGO INT PRIMARY KEY,
ID_PEDIDO INT NOT NULL,
FECHA_PAGO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
MONTO DECIMAL(10,2) NOT NULL,
METODO_PAGO VARCHAR(30) NOT NULL,
NUMERO_REFERENCIA VARCHAR(50),
ESTADO VARCHAR(20) DEFAULT 'Completado',

FOREIGN KEY (ID_PEDIDO) REFERENCES PEDIDOS(ID_PEDIDO),
CHECK (MONTO > 0),
CHECK (METODO_PAGO IN ('Efectivo', 'Tarjeta Crédito', 'Tarjeta Débito', 'Transferencia', 'PSE')),
CHECK (ESTADO IN ('Pendiente', 'Completado', 'Rechazado', 'Reembolsado'))
);
-- BETWEEN: Productos en un rango de precio
SELECT NOMBRE_PRODUCTO, PRECIO_UNITARIO
FROM PRODUCTOS
WHERE PRECIO_UNITARIO BETWEEN 50000 AND 200000;

-- IN: Clientes de ciudades específicas
SELECT NOMBRE, CIUDAD
FROM CLIENTES
WHERE CIUDAD IN ('Bogotá', 'Medellín', 'Cali');

-- LIKE: Buscar nombres que empiecen con 'J'
SELECT NOMBRE, APELLIDO
FROM CLIENTES
WHERE NOMBRE LIKE 'J%';

-- IS NULL: Clientes sin teléfono registrado
SELECT NOMBRE, EMAIL
FROM CLIENTES
WHERE TELEFONO IS NULL;

-- Nombres que empiezan con 'Mar'
WHERE NOMBRE LIKE 'Mar%'
-- María, Marta, Marcelo

-- Nombres que terminan con 'ez'
WHERE APELLIDO LIKE '%ez'
-- Pérez, González, Ramírez

-- Nombres que contienen 'ana'
WHERE NOMBRE LIKE '%ana%'
-- Juliana, Mariana, Susana

-- Códigos de 5 caracteres que empiezan con P
WHERE CODIGO LIKE 'P____'
-- P1234, PA5BC

-- Teléfonos con formato específico
WHERE TELEFONO LIKE '3__-____'
-- 300-1234, 312-5678

-- Ventas totales por cliente
SELECT ID_CLIENTE,
SUM(TOTAL) as VENTAS_TOTALES
FROM PEDIDOS
GROUP BY ID_CLIENTE;    

-- Ventas por cliente y estado
SELECT ID_CLIENTE,
ESTADO,
COUNT(*) as NUM_PEDIDOS,
SUM(TOTAL) as TOTAL_VENTAS
FROM PEDIDOS
GROUP BY ID_CLIENTE, ESTADO;
-- Clientes con más de 5 pedidos
SELECT ID_CLIENTE,
COUNT(*) as NUM_PEDIDOS,
SUM(TOTAL) as TOTAL_GASTADO
FROM PEDIDOS
GROUP BY ID_CLIENTE
HAVING COUNT(*) > 5;

-- Productos con stock bajo por categoría
SELECT ID_CATEGORIA,
COUNT(*) as PRODUCTOS_STOCK_BAJO
FROM PRODUCTOS
WHERE STOCK_ACTUAL < STOCK_MINIMO
GROUP BY ID_CATEGORIA
HAVING COUNT(*) >= 3;

SELECT
C.ID_CLIENTE,
C.NOMBRE,
C.APELLIDO,
COUNT(P.ID_PEDIDO) as TOTAL_PEDIDOS,
SUM(P.TOTAL) as VENTAS_TOTALES
FROM CLIENTES C
JOIN PEDIDOS P ON C.ID_CLIENTE = P.ID_CLIENTE
WHERE P.ESTADO = 'Entregado'
GROUP BY C.ID_CLIENTE, C.NOMBRE, C.APELLIDO
ORDER BY VENTAS_TOTALES DESC
LIMIT 10;

SELECT
CAT.NOMBRE_CATEGORIA,
P.NOMBRE_PRODUCTO,
SUM(DP.CANTIDAD) as UNIDADES_VENDIDAS,
SUM(DP.SUBTOTAL) as INGRESOS_TOTALES
FROM CATEGORIAS CAT
JOIN PRODUCTOS P ON CAT.ID_CATEGORIA =
P.ID_CATEGORIA
JOIN DETALLE_PEDIDOS DP ON P.ID_PRODUCTO =
DP.ID_PRODUCTO
JOIN PEDIDOS PED ON DP.ID_PEDIDO =
PED.ID_PEDIDO
WHERE PED.ESTADO = 'Entregado'
GROUP BY CAT.NOMBRE_CATEGORIA,
P.NOMBRE_PRODUCTO
ORDER BY CAT.NOMBRE_CATEGORIA,
UNIDADES_VENDIDAS DESC;

SELECT
P.ID_PRODUCTO,
P.NOMBRE_PRODUCTO,
C.NOMBRE_CATEGORIA,
P.STOCK_ACTUAL,
P.STOCK_MINIMO,
(P.STOCK_MINIMO - P.STOCK_ACTUAL) as
DEFICIT
FROM PRODUCTOS P
JOIN CATEGORIAS C ON P.ID_CATEGORIA =
C.ID_CATEGORIA
WHERE P.STOCK_ACTUAL < P.STOCK_MINIMO
AND P.ACTIVO = TRUE
ORDER BY DEFICIT DESC;

-- Especificando columnas
INSERT INTO CLIENTES
(ID_CLIENTE, NOMBRE, APELLIDO, EMAIL)
VALUES
(1, 'Juan', 'Pérez', 'juan@email.com');

-- Todas las columnas en orden
INSERT INTO CLIENTES
VALUES
(2, 'María', 'García',
'maria@email.com', '3001234567',
'Calle 123', 'Bogotá',
CURRENT_DATE, TRUE);

-- Más eficiente que múltiples INSERT
INSERT INTO CATEGORIAS
(ID_CATEGORIA, NOMBRE_CATEGORIA)
VALUES
(1, 'Electrónica'),
(2, 'Ropa'),
(3, 'Alimentos'),
(4, 'Libros'),
(5, 'Deportes');

UPDATE nombre_tabla
SET columna1 = valor1,
columna2 = valor2
WHERE condición;

-- Actualizar email de un cliente
UPDATE CLIENTES
SET EMAIL = 'nuevo@email.com'
WHERE ID_CLIENTE = 1;

-- Actualizar múltiples columnas
UPDATE PRODUCTOS
SET PRECIO_UNITARIO = 150000,
STOCK_ACTUAL = 50
WHERE ID_PRODUCTO = 101;

-- Aumentar precios 10% en una categoría
UPDATE PRODUCTOS
SET PRECIO_UNITARIO = PRECIO_UNITARIO * 1.10
WHERE ID_CATEGORIA = 1;

-- Desactivar clientes sin compras en 6 meses
UPDATE CLIENTES
SET ACTIVO = FALSE
WHERE ID_CLIENTE NOT IN (
SELECT DISTINCT ID_CLIENTE
FROM PEDIDOS
WHERE FECHA_PEDIDO >= CURRENT_DATE - INTERVAL '6 months'
);

-- Actualizar stock después de venta
UPDATE PRODUCTOS
SET STOCK_ACTUAL = STOCK_ACTUAL - 5
WHERE ID_PRODUCTO = 201
AND STOCK_ACTUAL >= 5;

-- Eliminar un cliente
específico
DELETE FROM CLIENTES
WHERE ID_CLIENTE = 999;

-- Eliminar productos
descontinuados
DELETE FROM PRODUCTOS
WHERE ACTIVO = FALSE
AND STOCK_ACTUAL = 0;

-- Eliminar pedidos
cancelados antiguos
DELETE FROM PEDIDOS
WHERE ESTADO =
'Cancelado'
AND FECHA_PEDIDO <
CURRENT_DATE - INTERVAL
'1 year';

-- Eliminar basado en
subconsulta
DELETE FROM
DETALLE_PEDIDOS
WHERE ID_PEDIDO IN (
SELECT ID_PEDIDO
FROM PEDIDOS
WHERE ESTADO =
'Cancelado'
);

-- DELETE: elimina fila por fila
DELETE FROM
TABLA_TEMPORAL;

-- TRUNCATE: más rápido,
elimina todo
TRUNCATE TABLE
TABLA_TEMPORAL;

-- Iniciar transacción
BEGIN TRANSACTION;

-- Reducir stock en bodega origen
UPDATE PRODUCTOS
SET STOCK_ACTUAL = STOCK_ACTUAL - 10
WHERE ID_PRODUCTO = 101 AND STOCK_ACTUAL >= 10;

-- Si no hay suficiente stock, la primera actualización falla
-- En ese caso, ROLLBACK deshace todo

-- Aumentar stock en bodega destino
UPDATE PRODUCTOS
SET STOCK_ACTUAL = STOCK_ACTUAL + 10
WHERE ID_PRODUCTO = 101;

-- Registrar el movimiento
INSERT INTO MOVIMIENTOS_INVENTARIO
(ID_PRODUCTO, TIPO_MOVIMIENTO, CANTIDAD, FECHA)
VALUES
(101, 'Transferencia', 10, CURRENT_TIMESTAMP);

-- Si todo salió bien, confirmar cambios
COMMIT;

-- Si algo salió mal, deshacer todo
-- ROLLBACK;

SELECT C.NOMBRE,
P.FECHA_PEDIDO, P.TOTAL
FROM CLIENTES C
INNER JOIN PEDIDOS P
ON C.ID_CLIENTE =
P.ID_CLIENTE;

SELECT C.NOMBRE, P.TOTAL
FROM CLIENTES C
LEFT JOIN PEDIDOS P
ON C.ID_CLIENTE =
P.ID_CLIENTE;

SELECT C.NOMBRE, P.TOTAL
FROM CLIENTES C
FULL OUTER JOIN PEDIDOS P
ON C.ID_CLIENTE =
P.ID_CLIENTE;

SELECT C.NOMBRE, P.TOTAL
FROM CLIENTES C
RIGHT JOIN PEDIDOS P
ON C.ID_CLIENTE =
P.ID_CLIENTE;

SELECT
P.ID_PEDIDO,
C.NOMBRE as CLIENTE,
P.FECHA_PEDIDO,
PROD.NOMBRE_PRODUCTO,
DP.CANTIDAD,
DP.PRECIO_UNITARIO,
DP.SUBTOTAL
FROM PEDIDOS P
INNER JOIN CLIENTES C ON P.ID_CLIENTE =
C.ID_CLIENTE
INNER JOIN DETALLE_PEDIDOS DP ON
P.ID_PEDIDO = DP.ID_PEDIDO
INNER JOIN PRODUCTOS PROD ON
DP.ID_PRODUCTO = PROD.ID_PRODUCTO
WHERE P.FECHA_PEDIDO >= CURRENT_DATE -
INTERVAL '30 days'
ORDER BY P.FECHA_PEDIDO DESC;

SELECT
C.ID_CLIENTE,
C.NOMBRE,
C.APELLIDO,
C.EMAIL,
C.FECHA_REGISTRO
FROM CLIENTES C
LEFT JOIN PEDIDOS P ON C.ID_CLIENTE =
P.ID_CLIENTE
WHERE P.ID_PEDIDO IS NULL
AND C.FECHA_REGISTRO < CURRENT_DATE -
INTERVAL '90 days'
ORDER BY C.FECHA_REGISTRO;

SELECT
CAT.NOMBRE_CATEGORIA,
P.NOMBRE_PRODUCTO,
COUNT(DP.ID_DETALLE) as VECES_VENDIDO,
SUM(DP.CANTIDAD) as UNIDADES_TOTALES,
SUM(DP.SUBTOTAL) as INGRESOS_TOTALES
FROM PRODUCTOS P
INNER JOIN CATEGORIAS CAT ON P.ID_CATEGORIA
= CAT.ID_CATEGORIA
INNER JOIN DETALLE_PEDIDOS DP ON
P.ID_PRODUCTO = DP.ID_PRODUCTO
INNER JOIN PEDIDOS PED ON DP.ID_PEDIDO =
PED.ID_PEDIDO
WHERE PED.ESTADO = 'Entregado'
GROUP BY CAT.NOMBRE_CATEGORIA,
P.NOMBRE_PRODUCTO
HAVING SUM(DP.CANTIDAD) >= 10
ORDER BY UNIDADES_TOTALES DESC;

-- Clientes con compras superiores al promedio
SELECT NOMBRE, APELLIDO
FROM CLIENTES
WHERE ID_CLIENTE IN (
SELECT ID_CLIENTE
FROM PEDIDOS
GROUP BY ID_CLIENTE
HAVING SUM(TOTAL) > (
SELECT AVG(suma_cliente)
FROM (
SELECT SUM(TOTAL) as suma_cliente
FROM PEDIDOS
GROUP BY ID_CLIENTE
) subquery
)
);

-- Productos con ventas por encima del promedio
SELECT
P.NOMBRE_PRODUCTO,
V.TOTAL_VENDIDO
FROM PRODUCTOS P
JOIN (
SELECT
ID_PRODUCTO,
SUM(SUBTOTAL) as TOTAL_VENDIDO
FROM DETALLE_PEDIDOS
GROUP BY ID_PRODUCTO
) V ON P.ID_PRODUCTO = V.ID_PRODUCTO
WHERE V.TOTAL_VENDIDO > 1000000;

-- Productos que nunca se han vendido
SELECT P.NOMBRE_PRODUCTO, P.STOCK_ACTUAL
FROM PRODUCTOS P
WHERE NOT EXISTS (
SELECT 1
FROM DETALLE_PEDIDOS DP
WHERE DP.ID_PRODUCTO = P.ID_PRODUCTO
)
AND P.ACTIVO = TRUE;

-- Índice simple en columna frecuentemente buscada
CREATE INDEX idx_clientes_email
ON CLIENTES(EMAIL);

-- Índice compuesto para consultas que filtran por ambas columnas
CREATE INDEX idx_pedidos_cliente_fecha
ON PEDIDOS(ID_CLIENTE, FECHA_PEDIDO);

-- Índice único (similar a restricción UNIQUE)
CREATE UNIQUE INDEX idx_productos_codigo
ON PRODUCTOS(CODIGO_PRODUCTO);

-- Eliminar índice si ya no es necesario
DROP INDEX idx_clientes_email;

-- Vista: Resumen de clientes con sus compras
CREATE VIEW VISTA_CLIENTES_RESUMEN AS
SELECT
C.ID_CLIENTE,
C.NOMBRE,
C.APELLIDO,
C.EMAIL,
COUNT(P.ID_PEDIDO) as TOTAL_PEDIDOS,
COALESCE(SUM(P.TOTAL), 0) as TOTAL_GASTADO,
MAX(P.FECHA_PEDIDO) as ULTIMA_COMPRA
FROM CLIENTES C
LEFT JOIN PEDIDOS P ON C.ID_CLIENTE = P.ID_CLIENTE
GROUP BY C.ID_CLIENTE, C.NOMBRE, C.APELLIDO, C.EMAIL;

-- Usar la vista es simple
SELECT * FROM VISTA_CLIENTES_RESUMEN
WHERE TOTAL_GASTADO > 1000000;

-- Vista: Productos con bajo stock
CREATE VIEW VISTA_PRODUCTOS_BAJO_STOCK AS
SELECT
P.ID_PRODUCTO,
P.NOMBRE_PRODUCTO,
C.NOMBRE_CATEGORIA,
P.STOCK_ACTUAL,
P.STOCK_MINIMO,
(P.STOCK_MINIMO - P.STOCK_ACTUAL) as DEFICIT
FROM PRODUCTOS P
JOIN CATEGORIAS C ON P.ID_CATEGORIA = C.ID_CATEGORIA
WHERE P.STOCK_ACTUAL < P.STOCK_MINIMO
AND P.ACTIVO = TRUE;

CREATE PROCEDURE nombre_proc
@parametro1 tipo,
@parametro2 tipo
AS
BEGIN
-- Código SQL aquí
END;
EXEC nombre_proc valor1, valor2;

CREATE PROCEDURE sp_registrar_cliente
@nombre VARCHAR(100),
@apellido VARCHAR(100),
@email VARCHAR(100),
@telefono VARCHAR(20),
@ciudad VARCHAR(50)
AS
BEGIN
-- Verificar si email ya existe
IF EXISTS (SELECT 1 FROM CLIENTES WHERE EMAIL = @email)
BEGIN
RAISERROR('El email ya está registrado', 16, 1);
RETURN;
END

-- Insertar nuevo cliente
INSERT INTO CLIENTES
(NOMBRE, APELLIDO, EMAIL, TELEFONO, CIUDAD, FECHA_REGISTRO, ACTIVO)
VALUES
(@nombre, @apellido, @email, @telefono, @ciudad, CURRENT_DATE, TRUE);

-- Devolver ID del nuevo cliente
SELECT SCOPE_IDENTITY() as NUEVO_ID_CLIENTE;
END;

-- Uso del procedimiento
EXEC sp_registrar_cliente
'Carlos', 'Rodríguez', 'carlos@email.com', '3009876543', 'Medellín';

CREATE TRIGGER nombre_trigger
AFTER INSERT ON tabla
FOR EACH ROW
BEGIN
-- Código del trigger
END;

-- Primero crear tabla de auditoría
CREATE TABLE AUDITORIA_PRECIOS (
ID_AUDITORIA INT PRIMARY KEY AUTO_INCREMENT,
ID_PRODUCTO INT NOT NULL,
PRECIO_ANTERIOR DECIMAL(10,2),
PRECIO_NUEVO DECIMAL(10,2),
FECHA_CAMBIO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
USUARIO VARCHAR(50)
);

-- Crear trigger que registra cambios de precio
CREATE TRIGGER trg_auditoria_precio_producto
AFTER UPDATE ON PRODUCTOS
FOR EACH ROW
BEGIN
IF OLD.PRECIO_UNITARIO != NEW.PRECIO_UNITARIO THEN
INSERT INTO AUDITORIA_PRECIOS
(ID_PRODUCTO, PRECIO_ANTERIOR, PRECIO_NUEVO, USUARIO)
VALUES
(NEW.ID_PRODUCTO, OLD.PRECIO_UNITARIO,
NEW.PRECIO_UNITARIO, CURRENT_USER());
END IF;
END;

CREATE FUNCTION calcular_descuento
(@precio DECIMAL(10,2),
@porcentaje INT)
RETURNS DECIMAL(10,2)
AS
BEGIN
RETURN @precio * (1 - @porcentaje/100.0);
END;

-- Uso
SELECT
NOMBRE_PRODUCTO,
PRECIO_UNITARIO,
dbo.calcular_descuento(PRECIO_UNITARIO, 15)
as PRECIO_CON_DESCUENTO
FROM PRODUCTOS;

CREATE FUNCTION obtener_pedidos_cliente
(@id_cliente INT)
RETURNS TABLE
AS
RETURN (
SELECT
ID_PEDIDO,
FECHA_PEDIDO,
TOTAL,
ESTADO
FROM PEDIDOS
WHERE ID_CLIENTE = @id_cliente
);

-- Uso
SELECT * FROM obtener_pedidos_cliente(101);

-- Primero verifica
SELECT * FROM CLIENTES WHERE ACTIVO =
FALSE;

-- Luego actualiza
UPDATE CLIENTES SET ACTIVO = TRUE
WHERE ID_CLIENTE IN (lista_verificada);